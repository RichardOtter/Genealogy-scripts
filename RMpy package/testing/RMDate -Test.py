import sys
from pathlib import Path
sys.path.append(str(Path.resolve(Path(__file__).resolve().parent / '../../RMpy package')))
# have to look 2 levels up for the folder containing the package

import RMpy.RMDate
from datetime import date
import RMpy.common as RMc
import datetime


# ===================================================DIV60==
def main():

    date_test_database_folder = Path(r"C:\Users\rotter\dev\Genealogy\Test Data\Sort date example DB")
    date_test_database_filename = Path(r"TEST DATA Dates -format_v11 -dump -reduced -v003 -RW.rmtree")

    # Use UTF-8 encoding for the report file. Test for write-ability
    report_path = Path("RMpy Package", "testing", "Result_Reports", r"Test_Results  " + RMc.time_stamp_now("file") + ".txt")
    report_file = open(report_path,  mode='w', encoding='utf-8')

    db_path = date_test_database_folder / date_test_database_filename

    # RM database file info
    file_modification_time = datetime.datetime.fromtimestamp(
        db_path.stat().st_mtime)

     # write header to report file
    format = "%Y-%m-%d %H:%M:%S"
    report_file.write(
            F"Report generated at      = {RMc.time_stamp_now()}\n"
            F"Utility name             = RMDate -test\n"
            F"Python version           = v{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}\n"
            F"Database last changed on = {file_modification_time.strftime(format)}\n"
            F"Database processed       = {db_path.resolve()}\n"
            F"\n\n\n")

    test_data = get_test_data(db_path)

    display_test_data(test_data, report_file)
    
    report_file.write("\nToday, RMdate, RMSortDate")
    report_file.write(str(date.today()) + '\n')
    report_file.write(RMpy.RMDate.now_RMDate() + '\n' )
    report_file.write(str(RMpy.RMDate.now_RMSortDate()) + '\n')
   
    report_file.write("===========================================DIV50==\n")

    try:
        RunTestList = False

        for item in test_data:
            if RunTestList:
                # run just these test 
                if item[0] not in ( 77,):   
                    continue
            else:
                pass
                # SKIP THESE TESTS
    
              #  if item[0] in (38, 39, 40): 
              #      continue # SORT date set differently than main date
              #  if item[0] in (66,): 
              #      continue # out of range date, sort date generated by RM is wrong
            Test(item, report_file)
        pass
   # PauseWithMessage()
    except RMc.RM_Py_Exception as exp:
        report_file.write(str(exp))
    
    finally:
        report_file.close()

    return


# ===================================================DIV60==
def Test(test_item, report_file):
    try:
        #   types of date
        #   human readable with 8 formats and internal storage date
        #   internal dates can be displayed as human readable in 8 formats
        #   human readable canonical form can be converted to internal storage dates
        #   human readable non-canonical form can be parsed to a canonical form and then converted

        #   internal Date   (RMDate)
        #   internal Sort Date 
        #   human readable Date
        #   human readable Sort Date

        # parse the test item from the large array
        in_DB_EvemtID = test_item[0]
        in_DB_RMdate = test_item[2]
        in_DB_Sortdate = int(test_item[3])
        in_GUI_full_date =  parse_description(test_item[4], 0 )
        in_GUI_sort_date =  parse_description(test_item[4], 1 )
        in_GUI_description = parse_description(test_item[4], 2 )

        # make the function calls and save the results.
        out_human_readable_from_RMDate= RMpy.RMDate.from_RMDate(in_DB_RMdate, RMpy.RMDate.Format.LONG)
        out_SortDate_from_RMDate = RMpy.RMDate.to_RMSortDate(in_DB_RMdate)
        out_RMDate_from_SortDate= RMpy.RMDate.from_RMSortDate(in_DB_Sortdate)
        out_std_fmt_from_DB_SortDate= RMpy.RMDate.from_RMDate(out_RMDate_from_SortDate, RMpy.RMDate.Format.LONG)

        # Test the results against expected
        # DB internal date to human readable vs GUI date

        print(f"\n\n\n{in_DB_EvemtID=}\n{in_GUI_description=}\n{in_GUI_sort_date=}\n{out_RMDate_from_SortDate=}\n{out_std_fmt_from_DB_SortDate=}\n")

        print("Compare normal format date derived from RMDate   vs. normal format as shown in RM GUI (tests from_RMDate)")
        if out_human_readable_from_RMDate != in_GUI_full_date:
            print("   {} ======= '{}'  !=  '{}'  ".format(in_DB_EvemtID, out_human_readable_from_RMDate, in_GUI_full_date))
        else:
            print("   {}     '{}'  ==  '{}'  ".format(    in_DB_EvemtID, out_human_readable_from_RMDate, in_GUI_full_date))

        print("Compare sort date derived from RMDate   vs. sort date from DB   (tests to_RMSortDate)")

        # out_internal_Sortdate vs TD_internal_Sortdate
        if out_SortDate_from_RMDate != in_DB_Sortdate:
            print("   {} ======= '{}'  !=  '{}'  ".format(in_DB_EvemtID, out_SortDate_from_RMDate, in_DB_Sortdate))
        else:
            print("   {}     '{}'  ==  '{}'  ".format(    in_DB_EvemtID, out_SortDate_from_RMDate, in_DB_Sortdate))

#        # DB internal SORT date to human readable vs GUI sort date
#        if out_human_readable_from_internal_sort_Date != GUI_sort_date:
#            print("   {} ======= '{}'  !=  '{}'  ".format(TD_EvemtID, out_human_readable_from_internal_sort_Date, GUI_sort_date))
#        else:
#            print("   {}     '{}'  ==  '{}'  ".format(TD_EvemtID, out_human_readable_from_internal_sort_Date, GUI_sort_date))


        #   print(RMDate.FromRMDate(In, RMDate.Format.LONG) + "==")

    except Exception as e:
        report_file.write("\n========================== A test case caused an exception. Continue with next." + str(e) + "\n")

# ===================================================DIV60==
def get_test_data(db_path : Path, display_data : bool = True) -> []:
        
    if not db_path.exists():
        raise RMc.RM_Py_Exception(
            F'ERROR: Database path not found:\n'
            F' "{db_path}"\n')
    
    db_connection = RMc.create_db_connection(db_path, None)

    db_cursor = db_connection.cursor()

    SQL_stmt = """
SELECT EventID, ftt.Name, et.Date, et.SortDate, et.Details
FROM EventTable AS et
INNER JOIN FactTypeTable AS ftt ON et.EventType = ftt.FactTypeID
WHERE Name COLLATE NOCASE != 'C_Quaker' 
AND Name COLLATE NOCASE != 'C_JulGeor'
AND Name COLLATE NOCASE NOT LIKE 'Quar%'
ORDER BY Name COLLATE NOCASE ASC;  
"""
    db_cursor.execute(SQL_stmt)

    test_data = []
    for row in db_cursor:
        test_data.append( (row[0], row[1], row[2], row[3], row[4] ) )
    
    return test_data
    

# ===================================================DIV60==
def display_test_data(test_data, report_file):

    # Compute max width of each column
    col_widths = [max(len(str(row[i])) for row in test_data)
                for i in range(len(test_data[0]))]

    for row in test_data:
        line = "  ".join(str(val).ljust(col_widths[i])
                        for i, val in enumerate(row)
                    )
        report_file.write( line + '\n')


# ===================================================DIV60==
def parse_description(In, which):
    # Fact description=   full Date || Sort Date  || comments
    # 0 human readable date, format= 10 January 1959
    # 1 human readable sort date, format= 10 January 1959

    # all formats (from RM v9 preferences)
    #  10 Jan 1959
    #  Jan 10, 1959
    #  10 January 1950
    #  January 10, 1959
    #  10 JAN 1959
    #  JAN 10, 1950
    #  10 JANUARY 1950
    #  JANUARY 10, 1950

    parsed=  (In.split("||") [which])
    return parsed.strip()


# ===================================================DIV60==
def PauseWithMessage(message=None):
    if (message != None):
        print(message)
    input("\nPress the <Enter> key to continue...")
    return


# ===================================================DIV60==
# Call the "main" function
if __name__ == '__main__':

    main()

# ===================================================DIV60==
